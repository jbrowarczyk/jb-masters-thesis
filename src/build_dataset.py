from global_settings import EEG_CHANNELS, N_CHANNELS, FS, FRAME_DURATION, N_SAMPLES, N_OVERLAP
import numpy as np
import mne
import os
import sys

def split_with_margins(input_data, number_of_parts, length_of_outer_margin, length_of_inner_margin):

	slice_length = int(np.floor((len(input_data) - 2*length_of_outer_margin - (number_of_parts-1)*length_of_inner_margin)/number_of_parts))
	if slice_length<0:
		raise ValueError('bad margin lengths')
	current_index = length_of_outer_margin

	output_slices = []
	for i in range(number_of_parts):
		slice_start = current_index
		slice_end   = current_index + slice_length
		current_index += (slice_length + length_of_inner_margin)
		output_slices.append(input_data[slice_start:slice_end])
	return output_slices

# EDF standard files - for instance, ones generated by Emotiv software
def dataset_handler_routine_edf(directory):
	Fs = 128
	class_meditation    = []
	class_music_video   = []
	class_logic_game    = []
	list_of_contents = os.listdir(directory)
	#print('checking directory: ', directory)
	for file in list_of_contents:
		if os.path.isdir(file):
			continue
		if os.path.splitext(file)[1] == '.edf':
			#print('\t loading file: ', file)
			raw = mne.io.read_raw_edf(directory+'/'+file, verbose=False)
			# raw.plot(block=True, lowpass=40)

			# for name in dir(raw): print(name)

			names_of_channels   = raw.ch_names
			channel_data        = raw.get_data()

			channel_dictionary  = {}

			for channel_name, channel_data in zip(names_of_channels, channel_data):
				if channel_name not in EEG_CHANNELS:
					continue
				channel_dictionary.update({channel_name:channel_data})

			class_meditation_sample     = {}
			class_music_video_sample    = {}
			class_logic_game_sample     = {}

			for key, value in channel_dictionary.items():
				eeg_data        = np.array(value)
				distance_in_seconds = 50
				split_signals   = split_with_margins(eeg_data,3,distance_in_seconds*Fs, distance_in_seconds*Fs)
				class_meditation_sample.update({key:split_signals[0]})
				class_music_video_sample.update({key:split_signals[1]})
				class_logic_game_sample.update({key:split_signals[2]})

			class_meditation.append(class_meditation_sample)
			class_music_video.append(class_music_video_sample)
			class_logic_game.append(class_logic_game_sample)

	data_eeg = {'meditation': class_meditation, 'music_video': class_music_video, 'logic_game': class_logic_game}
	return data_eeg

def eeg_dict_to_matrix(eeg_dict):
	output_matrix = []
	for channel_name in EEG_CHANNELS:
		output_matrix.append(eeg_dict[channel_name])
	return np.matrix(output_matrix)

def split_to_frames_with_overlap(data_eeg, frame_length,overlap):
	if(overlap >= frame_length):
		raise Exception("Overlap can't be greater than or equal to frame length")
	if(overlap < 0):
		raise Exception("Overlap can't be lesser than 0")
	output_structure = {}
	step = frame_length - overlap
	for class_name in data_eeg.keys():
		output_structure.update({class_name:[]})
		for sample_idx in range(len(data_eeg[class_name])):
			matrix_of_channels = eeg_dict_to_matrix(data_eeg[class_name][sample_idx])
			output_structure[class_name].append(split_matrix_to_frames_with_step(matrix_of_channels, frame_length, step))
	return output_structure

def split_matrix_to_frames_with_step(matrix, frame_length,step):
	output_vector_of_matrices = []
	
	length_of_signals = matrix.shape[1]
	i = 0
	while(i + frame_length <= length_of_signals):
		output_vector_of_matrices.append(matrix[:,i:i+frame_length])
		i += step
		
	return output_vector_of_matrices

def main():
	try:
		print("Building the dataset...")
		DATA_DIR = '_data/New Samples'
		data_eeg = dataset_handler_routine_edf(DATA_DIR)  
		preprocessed_eeg = split_to_frames_with_overlap(data_eeg, N_SAMPLES, N_OVERLAP)
		print("Dataset built")
	except Exception as e:
		print("Error during building the dataset")
		print(e)
		sys.exit()
	try:
		print("Saving the dataset...")
		np.save('eeg_signals.npy',preprocessed_eeg)
		print("Dataset saved")	
	except Exception as e:
		print("Error during saving the dataset")
		print(e)
		sys.exit()	


if __name__ == "__main__":
	main()
	